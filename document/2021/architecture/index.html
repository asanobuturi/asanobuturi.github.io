<!doctype html><html lang=ja><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=description content="オブジェクト指向と、コンピュータープログラムの構造を考察。"><meta name=viewport content="width=device-width,initial-scale=1"><link rel=stylesheet href=/styles.css><link rel=stylesheet href=/highlight.css><link rel=icon href=/image/favicon.svg type=image/svg+xml><link rel="icon alternate" href=/images/favicon.ico><meta property="og:site_name" content="浅野学園物理部"><meta property="og:url" content="https://asanobuturi.github.io/document/2021/architecture/index.html"><meta property="og:title" content="アーキテクチャへの扉｜浅野学園物理部"><meta property="og:description" content="オブジェクト指向と、コンピュータープログラムの構造を考察。"><meta property="og:type" content="website"><meta property="og:image" content="https://asanobuturi.github.io/thumbnails/document/2021/architecture/thumbnail.jpg"><meta name=twitter:card content="summary_large_image"><meta name=twitter:site content="@Uchi54_APC"><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=M+PLUS+Rounded+1c:wght@500;700&display=swap" rel=stylesheet></head><link rel=stylesheet href=/blog_new.css><link rel=stylesheet href=/highlight.css><script src=https://kit.fontawesome.com/1e291c4f9b.js crossorigin=anonymous></script><title>アーキテクチャへの扉｜浅野学園物理部</title><script type=text/javascript async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS_CHTML"></script><body><div id=nav-drawer><input id=nav-input type=checkbox class=nav-unshown>
<label id=nav-open for=nav-input><span class="bar bar1"></span><span class="bar bar2"></span><span class="bar bar3"></span><span class=menu>MENU</span>
<span class=close>CLOSE</span></label>
<label id=nav-close for=nav-input></label><div id=nav-content><a href=/index.html><img src=/image/MenuBarLogo.webp id=nav-logo alt=浅野学園物理部></a>
<a class=nav-link href=/index.html>ホーム</a>
<a class=nav-link href=/about/index.html>物理部とは</a>
<a class="nav-link isActive" href=/document/index.html>部誌</a>
<a class=nav-link href=/game/index.html>ゲーム</a>
<a class=nav-link href=/blog/index.html>ブログ</a>
<a class=nav-link href=/electronic/index.html>電工の部屋</a><div class=nav-separator></div><a class=nav-link href=http://d.hatena.ne.jp/apc/>ブログ(外部サイト)</a></div></div><main><div id=main><div class=documentcontent><div id=breadcrumbs><i class="fas fa-home"></i><a href=/index.html>ホーム</a>
<i class="fas fa-angle-right"></i><a href=../../index.html>部誌</a>
<i class="fas fa-angle-right"></i><a href=../index.html>2021年度部誌</a>
<i class="fas fa-angle-right"></i><a href=./index.html>アーキテクチャへの扉</a></div><header class=documenttitle><h1 id=title>アーキテクチャへの扉</h1><p class=author><i class="fas fa-user-edit"></i>名誉部外部員 むら(高2)</p><a href="https://twitter.com/intent/tweet?text=%e3%82%a2%e3%83%bc%e3%82%ad%e3%83%86%e3%82%af%e3%83%81%e3%83%a3%e3%81%b8%e3%81%ae%e6%89%89&via=Uchi54_APC&related=Uchi54_APC" class=twitter-share-button data-show-count=false>ツイート</a>
<script async src=https://platform.twitter.com/widgets.js></script></header><div class=document><h2 id=はじめに免責>はじめに（免責）</h2><p>この記事はネットや本などで知識だけを身に着けた経験の浅い人が書いています。この人はこんな考え方をしているんだなぁ位にこの記事を読み流してきちんとした本を読むことをお勧めします。本記事の考えのもとになっている本はを最後に紹介します。</p><h2 id=本記事の目標>本記事の目標</h2><p>本記事ではプログラムとはどんなものか、またオブジェクト指向とは何かを説明しながらプログラムの大まかな構造を考えていきます。最終的に、良いと言われているようなプログラムの構造を考えられればなと思います。</p><p>プログラムの評価は使う人が直接触るわけではないので、いわゆる絵や音楽などの受け手からの評価とは違ってきます。プログラムに触れるのは仕様を変更したり追加したりする同業者または自分です。つまり、プログラムはそれを作り替える人から評価を受けるわけです。よって良いプログラムとは仕様を変更したり追加したりしやすいプログラムということになります。</p><p>プログラムを評価する指標は大まかに三つほどあります。一つ目は<strong>読みやすさ</strong>です。読みづらければプログラムを理解することが大変になってしまいます。二つ目は<strong>再利用のしやすさ</strong>です。同じようなものを何度も書いているとプログラムが無駄に大きくなってしまいますし、それだけ労力がかかってしまいます。三つめは<strong>正しさ</strong>です。当然ですがバグが多いプログラムはプログラマに対してだけでなくユーザーに対しても被害が出ます。</p><h2 id=プログラム>プログラム</h2><blockquote><p>コンピュータプログラム（英：computer program）とは、コンピュータに対する命令（処理）を記述したものである。</p></blockquote><p>Wikipediaからプログラムの説明を引用してきました。プログラムは仕事の手順を示した<strong>静的な</strong>データです。</p><figure><img src=./chocolate_recipe.png style=width:100% alt=https://cookpad.com/recipe/2477629><figcaption aria-hidden=true>https://cookpad.com/recipe/2477629</figcaption></figure><p>これは生チョコのレシピの一部です。プログラムはこのような料理のレシピと同じように「最初にこれをやる、次にこれをやる……」ということが書かれたデータです。</p><p>料理をするときには材料が必要となり、その材料をもとに食べ物を作ります。プログラムも同じく、あるデータを使って決まった仕事を行い、得られたデータを出力します。つまり、<strong>プログラムは入力、処理、出力で構成されています</strong>。（このうちのどれかが欠けることはあります）関数について考えてみても、この構成要素がわかります。関数は引数が入力され、中である決まった処理をして、戻り値を出力します。関数はそれ自体が一つのプログラムになります。</p><p><strong>入力の段階で処理しやすいデータになっていると関数などで中に書くコードが少なくなるのでプログラムが単純になります</strong>。料理でいうところの下ごしらえです。3分クッキングでは下ごしらえを完璧にすましてあるので実際の処理内容（レシピ）がとても分かりやすくなっています。関数の中でデータを動的に取得して（現在時刻の取得など）から、そのデータと引数を使って処理をしたいことがあると思いますが、やってはいけません。これは処理の部分でデータを用意していることになります。また、ある引数を入れたときに常に同じ戻り値が返ってこないことになります。これは、<strong>入力と出力を見てプログラムが正しく動いているかどうか判断することができなくなる</strong>のでやってはいけません。現在時刻なども外で取得してから関数の引数などに渡しましょう。</p><h3 id=プログラムの依存関係>プログラムの依存関係</h3><p>プログラムはプログラムの中で使うことができます。関数の場合関数の呼び出しと言ったりします。<strong>依存関係は使うものと使われるものの関係です</strong>。使うものは使われるものに依存しているといいます。車で考えてみましょう。車はタイヤを使います。タイヤは車に使われます。車がなくてもタイヤの機能は成り立ちますが、タイヤがないと車の機能は成り立ちません。つまり、タイヤは車に依存しておらず、車はタイヤに依存していることがわかります。AプログラムがBプログラムを使っているとすると、BプログラムがないとAプログラムを使うことができませんが、AプログラムがなくてもBプログラムを使うことができます。なので、AプログラムはBプログラムに依存していることとなります。</p><p>さて、車はタイヤに依存していると話しましたが一般的に物が製品を使う、つまり製品が部品に依存するという関係が成り立っています。しかし、プログラムの中では部品と製品との違いがあいまいなことがよくあります。ではどのようにプログラムの依存関係を考えるかというと、<strong>より根本的かつ汎用的なプログラムのほうに依存します</strong>。製品と部品では部品のほうが汎用的です。汎用的な部品は一つの製品だけでなく、様々なところで使うことができます。タイヤはネジに依存していますが、ネジを使っている製品はとてもたくさんあります。また、AプログラムがBプログラムに依存しているとBプログラムの仕様が変わったときにAプログラムの仕様を変えなければならない可能性があります。しかし、その逆はありません。ネジの太さが変わってしまうとそのネジを使っているタイヤは使えなくなってしまいますが、タイヤのネジ穴が太くなってもネジが使えなくなることはありません。</p><h2 id=アプリケーション>アプリケーション</h2><p>アプリケーションはプログラムその物ではありません。入力、処理、出力では説明できないからです。ただ、アプリケーションの仕様を分解するとそれぞれを入力、処理、出力で説明できるようになります。ここから<strong>アプリケーションは複数のプログラムが集まって出来ている</strong>ことがわかります。</p><p>アプリケーションのユーザはパソコンやスマホなどのデバイスを操作して画面に何かが表示されたり音が鳴ったりすることを期待します<strong>。ユーザの操作がプログラムの手順を始めるトリガーとなり、処理に必要なデータを作ることがあります</strong>。</p><p>ユーザの操作から得られるデータ以外にアプリケーションやサーバ上にあるデータが必要となるときがあります。これらのデータを得るためのデータアクセサが必要になります。ユーザの操作によって得られるデータや、データベース、ファイルなどのデータはそのままでは処理に向いていないことがよくあります。よって、<strong>処理に必要なデータを処理しやすいデータに直すプログラムが必要になります</strong>。</p><p><strong>ロジックに必要なデータは様々なところから持ってくるので、それらを一括にまとめてロジックに渡せると便利です</strong>。様々なデータとプログラムを繋ぐことからこのプログラムをロジックと名付けます。</p><p>出力されるデータもただのデータでしかないので、出力されたデータを解釈して画面に表示したり音を鳴らしたりなどのユーザの体験を提供するプログラムが必要です。</p><p>これらを踏まえてアプリケーションの中のプログラムの基本的な構造を考えてみます。</p><ul><li class=li-normal>ユーザの操作で処理がスタートします</li><li class=li-normal>ユーザの操作で得た入力データを処理しやすいデータに変換し、「ジョイント」に入力します。</li><li class=li-normal>「ジョイント」で「データアクセサ」からファイルやデータベースのデータを持ってきて「ロジック」に入力します</li><li class=li-normal>「ロジック」で入力されたデータに対してある決まった処理を行い、得たデータを「ジョイント」に返します</li><li class=li-normal>「ジョイント」で帰ってきたデータを複数の「出力」に渡します。</li><li class=li-normal>「出力」で渡されたデータを解釈して画面に表示したり、音を鳴らしたりと様々なことをします</li></ul><p>これら一つ一つのプログラムも入力、処理、出力で出来ていることがわかります。</p><p>では、依存関係の話をアプリケーションのプログラムに応用してみましょう。アプリケーションのプログラムは基本的に入力、ロジック、出力、データアクセサ、ジョイントでできています。アプリケーションにとって根本的なのはロジックです。ロジックには仕様その物が書かれています。また、ロジックは同じ仕様の別アプリケーションでも使うことができます。</p><p>一方、入力、出力はアプリケーションごとにUIが異なり、UIが変わってもアプリケーションが成り立つ（パズドラは何回かUIが変わっています）ことから根本的ではないことがわかります。また、データアクセサもファイルの拡張子やデータベースの種類などによってアプリケーションの根本的な仕様は変わらないので根本的ではありません。</p><p>そして、ジョイントは入力、出力、データアクセサとロジックの間を取り持つので根本度も中間になります。よって、ジョイントがロジックに依存して入力、出力、データアクセサがジョイントに依存することになります。しかし、ジョイントはデータアクセサや出力を参照する必要があるのでこれらの依存関係を守ることは難しくなってしまいます。</p><figure><img src=./アプリケーション構造_手続き.jpeg style=width:100% alt=アプリケーション構造_手続き><figcaption aria-hidden=true>アプリケーション構造_手続き</figcaption></figure><h2 id=オブジェクト指向>オブジェクト指向</h2><p>これまで話した構造がBasicやC++などの手続き型言語で出来る構造です。この構造をC#やJavaなどのオブジェクト指向言語を使うことでさらに強化していきます。（PythonやC++などのオブジェクト指向言語では対応していない機能がありますが、代替手段があります。<del>多分</del>）ただ、その前にオブジェクト指向の機能はどんなものがあるか確認していきましょう。</p><h3 id=クラス>クラス</h3><p>クラスは型と呼ばれることもあります。型、つまり物を作るときに元となるものです。クラス自体は使うことができません。クラスを使って物を作るのですが、その物をインスタンスと呼びます。クラスには主にフィールドと呼ばれるデータ（変数）とメソッドと呼ばれるフィールドを使ったプログラムを定義することができます。クラスには二つの使い道があり、一つ目はインスタンスを生成することで、二つ目はインスタンスを入れる変数にすることです。</p><h3 id=インスタンス>インスタンス</h3><p>インスタンスの中にはクラスで定義されたデータとプログラムが入っています。このデータやプログラムは公開するか非公開にするかクラスで決めることができます。公開するとインスタンスの外で使うことができて、非公開にするとインスタンスの内側でしか使うことができません。</p><p>インスタンスには二種類の使い方があります。データのまとまりと共通のデータに対するプログラム群です。これは二種類の使い方どちらでも使えるわけではなく、どちらか一つの使い方に絞る必要があります。データのまとまりとして使うインスタンスをデータ構造、共通のデータに対するプログラム群として使うインスタンスをオブジェクトといいます。データ構造もオブジェクトもデータが主となっていることがわかります。よって、クラスはデータのまとまりとして名前を付けるべきです。</p><p>データ構造はデータのまとまりです。それ以上でもそれ以下でもありません。プログラムにデータを渡したりデータを出力したりするときに使います。データ構造はただのデータなのでクラス内には公開フィールドしか定義してはいけません。</p><p>プログラムは入力、処理、出力で出来ていると話しました。当然メソッドもそれに従わなければなりません。メソッドの入力は引数のほかにフィールドがあります。（メソッドにフィールドを入力しない場合、そのプログラムはメソッドではなく関数で実装した方がよいことになります）引数はメソッド内の処理を実行するときに入力するデータなのに対し、フィールドはあらかじめ決めておくデータになります。メソッドを使うときには引数しか設定しないのでフィールドをころころ変えてしまうとある引数に対して常に同じ戻り値が返ってこないことになります。よって、オブジェクトのフィールドは外からも（できれば中からも）変更できないようにするのが好ましいです。ここでフィールドを非公開にする必要が出てきます。オブジェクト内のデータが欲しいときには公開したいデータだけをまとめた専用のデータ構造のクラスを作り、そのインスタンスを返すメソッド（またはプロパティ）を返します。</p><h3 id=インターフェース>インターフェース</h3><p>インターフェースは各プログラムのつなぎ目です。インターフェースには実装されていないメソッド（またはプロパティ）を定義することができ、それらをクラスに実装させることで間接的にクラスのメソッド（またはプロパティ）を使うことができます。インターフェースは複数のクラスを「同じ機能を持つもの」として同じように扱えます。インターフェースを変数にすることによってその変数にはインターフェースが実装されているクラスだったらなんでも入れることができます。</p><p>また、インターフェースを介してクラスをつなぐことによって依存関係を逆転することができます。例えば、根本的なロジックを持つクラスAが詳細的なロジックを持つクラスBを参照したいとします。</p><figure><img src=./依存関係逆転_問題.jpeg style=width:50% alt=依存関係逆転の問題><figcaption aria-hidden=true>依存関係逆転の問題</figcaption></figure><p>しかし、これだと根本的なクラスが詳細的なクラスに依存していることになってしまいます。そこでクラスA専用のインターフェースBを用意してクラスBがそれを実装します。</p><figure><img src=./依存関係逆転_解決.jpeg style=width:50% alt=依存関係逆転の解決><figcaption aria-hidden=true>依存関係逆転の解決</figcaption></figure><p>インターフェースBはクラスA専用なのでクラスAが欲しい機能だけが定義されています。クラスAの仕様が変わりインターフェースBに対して必要な機能が変わるとインターフェースBは中身の処理を定義していないので簡単に機能を変えることができます。インターフェースBの機能を変えるとクラスBを変更するかインターフェースBの機能を持った新しいクラスを作る必要があります。これで詳細的なクラスBが根本的なクラスAに実質依存することができます。</p><h3 id=抽象クラス>抽象クラス</h3><p>抽象クラスはインスタンスを生成することができず、型として使います。その代わり抽象クラスを基に派生クラスをつくることができ、派生クラスは抽象クラスとして扱うこともできます。派生クラスはその名の通り抽象クラスから派生したものです。よって派生クラスは抽象クラスとして扱える必要があります。イメージとしては抽象クラスが種類、派生クラスが物となります。抽象クラスは厄介な機能なのであまり使う頻度は高くありません。というか安易に使ってはいけません。機能をまとめたいだけならインターフェースを使いましょう。</p><h2 id=オブジェクト指向を使ったプログラムの構造>オブジェクト指向を使ったプログラムの構造</h2><p>オブジェクト指向の主な機能を確認したところでこれをアプリケーションのプログラムに適用してみましょう。オブジェクト指向は再利用のしやすさに特化しています。</p><p>ソフトウェアのプログラムは入力、出力、ロジック、ジョイント、データアクセサで出来ていること、そして入力と出力がジョイントに依存していてジョイントがロジックに依存しているべきだということをプログラムの章で話しました。関数だけではこの依存関係にすることが難しいですが、オブジェクト指向の機能であるインターフェースによって依存関係を逆転させることで可能になります。</p><p>インスタンスを使うことによってデータとプログラムが一体となり、処理プログラムを再利用できるようになりました。そこで、様々なデータに対する処理をそれぞれクラスで定義し、それらを使って一つの大きな処理をこなすプログラムを作ります。このような小さなロジックを複数フィールドに持ち、それらをつかって大きな処理をするメソッドを持つオブジェクトを制御フロー(またはトランザクション)と名付けます。</p><p>ジョイントがデータアクセサのインターフェースに依存することでファイルの拡張子やデータベースのツールが変わったときもジョイント部分を一切変更せずにデータアクセサを付け替えるだけでよくなります。</p><p>これらの変更を加えたプログラムの構造を図にしてみます。</p><figure><img src=./アプリケーション構造_オブジェクト指向.jpeg style=width:100% alt=アプリケーション構造><figcaption aria-hidden=true>アプリケーション構造</figcaption></figure><p>この構造がアプリケーションの中に複数できることになります。ファイルやデータベース、画面表示やサーバ通信はそれぞれ例です。実際はこの構造からクラスを付け足したり減らしたりして仕様にあった構造を作ることになりますが基本的にこの構造を維持することでそれぞれの機能を再利用しやすくなると思います。また、使うツールによっては変換が必要ないデータが出てくる可能性があります。しかし、必ず別の処理専用のデータ構造にデータを移す必要があります。なぜなら、処理で扱うデータ構造と入力、出力で扱うデータ構造を一緒にすると入力、出力の都合でデータ構造を変更しなければいけなくなったときに処理もその影響を受けてしまうからです。</p><h2 id=先人の知恵>先人の知恵</h2><h3 id=今回のプログラムの構造に使われている知恵>今回のプログラムの構造に使われている知恵</h3><ul><li class=li-normal>DRY(Don’t repeat yourself)</li><li class=li-normal>OAOO(Once and only once)</li><li class=li-normal>SRP(Single Responsible Principle, 単一責務の原則)　注：名前に惑わされて間違った説明をしていることがあります</li><li class=li-normal>OCP(Open Closed Principle, オープンクローズドの原則)</li><li class=li-normal>ISP(Interface segregation principle, インターフェース分離の原則)</li><li class=li-normal>DIP(Dependency inversion principle, 依存性逆転の法則)</li><li class=li-normal>SDP(Stable-dependencies principle, 安定依存の原則)</li></ul><h3 id=プログラムの構造を考えるうえでの知恵>プログラムの構造を考えるうえでの知恵</h3><ul><li class=li-normal>GOFのデザインパターン　注：目的ではなく手段です</li><li class=li-normal>DDD(Domain-driven design, ドメイン駆動設計)</li><li class=li-normal>LSP(Liskov substitution principle, リスコフの置換原則)</li><li class=li-normal>求めるな、命じよ</li><li class=li-normal>デルメルの法則</li></ul><h3 id=読みやすいコードにするための知恵>読みやすいコードにするための知恵</h3><ul><li class=li-normal>PLS(Principle of least surprise, 驚き最小の原則)</li><li class=li-normal>ループバックチェック</li></ul><h3 id=正しいプログラムを作る上での知恵>正しいプログラムを作る上での知恵</h3><ul><li class=li-normal>テスト駆動設計</li><li class=li-normal>ハンブルオブジェクトパターン</li></ul><h3 id=おすすめの本>おすすめの本</h3><ul><li class=li-normal>リーダブルコード（清和書林にあります！！）</li><li class=li-normal>Clean Architecture</li><li class=li-normal>オブジェクト指向でなぜ作るのか（清和書林にあります！！）</li></ul><h2 id=さいごに>さいごに</h2><p>これまでつらつらと書いてきましたが、小さいアプリケーションではこの構造を完璧に守らなくてもあまり問題にならずにかけちゃいます。しかし、プログラムの構造を適切に作ることによって機能を拡張しやすくなるのは事実です。この記事でプログラムの構造を作る上で様々な考え方があることを知ってもらえたら幸いです。</p></div><nav class=nextPrev><div class=next>次へ<a href=https://asanobuturi.github.io/document/2021/ryzen/>AMDのZen3について考える ></a></div><div class=prev>前へ<a href=https://asanobuturi.github.io/document/2021/ai/>深層強化学習によるリバーシAI ></a></div></nav></div><nav id=sidebar><div id=sidemenu><div class=side-back><a href=../index.html>記事の一覧へもどる<i class="fas fa-sign-out-alt"></i></a></div><div class=side-next><a href=https://asanobuturi.github.io/document/2021/ryzen/>AMDのZen3について考える<i class="fas fa-angle-right"></i></a></div><div class=side-prev><a href=https://asanobuturi.github.io/document/2021/ai/><i class="fas fa-angle-left"></i>深層強化学習によるリバーシAI</a></div></div><div id=indexblock><div class=indextitle>目次</div><ol class=indexcontents></li><li><a href=#%e3%81%af%e3%81%98%e3%82%81%e3%81%ab%e5%85%8d%e8%b2%ac>はじめに（免責）</a></li><li><a href=#%e6%9c%ac%e8%a8%98%e4%ba%8b%e3%81%ae%e7%9b%ae%e6%a8%99>本記事の目標</a></li><li><a href=#%e3%83%97%e3%83%ad%e3%82%b0%e3%83%a9%e3%83%a0>プログラム</a><ol><li><a href=#%e3%83%97%e3%83%ad%e3%82%b0%e3%83%a9%e3%83%a0%e3%81%ae%e4%be%9d%e5%ad%98%e9%96%a2%e4%bf%82>プログラムの依存関係</a></li></ol></li><li><a href=#%e3%82%a2%e3%83%97%e3%83%aa%e3%82%b1%e3%83%bc%e3%82%b7%e3%83%a7%e3%83%b3>アプリケーション</a></li><li><a href=#%e3%82%aa%e3%83%96%e3%82%b8%e3%82%a7%e3%82%af%e3%83%88%e6%8c%87%e5%90%91>オブジェクト指向</a><ol><li><a href=#%e3%82%af%e3%83%a9%e3%82%b9>クラス</a></li><li><a href=#%e3%82%a4%e3%83%b3%e3%82%b9%e3%82%bf%e3%83%b3%e3%82%b9>インスタンス</a></li><li><a href=#%e3%82%a4%e3%83%b3%e3%82%bf%e3%83%bc%e3%83%95%e3%82%a7%e3%83%bc%e3%82%b9>インターフェース</a></li><li><a href=#%e6%8a%bd%e8%b1%a1%e3%82%af%e3%83%a9%e3%82%b9>抽象クラス</a></li></ol></li><li><a href=#%e3%82%aa%e3%83%96%e3%82%b8%e3%82%a7%e3%82%af%e3%83%88%e6%8c%87%e5%90%91%e3%82%92%e4%bd%bf%e3%81%a3%e3%81%9f%e3%83%97%e3%83%ad%e3%82%b0%e3%83%a9%e3%83%a0%e3%81%ae%e6%a7%8b%e9%80%a0>オブジェクト指向を使ったプログラムの構造</a></li><li><a href=#%e5%85%88%e4%ba%ba%e3%81%ae%e7%9f%a5%e6%81%b5>先人の知恵</a><ol><li><a href=#%e4%bb%8a%e5%9b%9e%e3%81%ae%e3%83%97%e3%83%ad%e3%82%b0%e3%83%a9%e3%83%a0%e3%81%ae%e6%a7%8b%e9%80%a0%e3%81%ab%e4%bd%bf%e3%82%8f%e3%82%8c%e3%81%a6%e3%81%84%e3%82%8b%e7%9f%a5%e6%81%b5>今回のプログラムの構造に使われている知恵</a></li><li><a href=#%e3%83%97%e3%83%ad%e3%82%b0%e3%83%a9%e3%83%a0%e3%81%ae%e6%a7%8b%e9%80%a0%e3%82%92%e8%80%83%e3%81%88%e3%82%8b%e3%81%86%e3%81%88%e3%81%a7%e3%81%ae%e7%9f%a5%e6%81%b5>プログラムの構造を考えるうえでの知恵</a></li><li><a href=#%e8%aa%ad%e3%81%bf%e3%82%84%e3%81%99%e3%81%84%e3%82%b3%e3%83%bc%e3%83%89%e3%81%ab%e3%81%99%e3%82%8b%e3%81%9f%e3%82%81%e3%81%ae%e7%9f%a5%e6%81%b5>読みやすいコードにするための知恵</a></li><li><a href=#%e6%ad%a3%e3%81%97%e3%81%84%e3%83%97%e3%83%ad%e3%82%b0%e3%83%a9%e3%83%a0%e3%82%92%e4%bd%9c%e3%82%8b%e4%b8%8a%e3%81%a7%e3%81%ae%e7%9f%a5%e6%81%b5>正しいプログラムを作る上での知恵</a></li><li><a href=#%e3%81%8a%e3%81%99%e3%81%99%e3%82%81%e3%81%ae%e6%9c%ac>おすすめの本</a></li></ol></li><li><a href=#%e3%81%95%e3%81%84%e3%81%94%e3%81%ab>さいごに</a></ol></div></nav></div><footer class=footer><p class=copyright>Copyright &copy; 2015 - 2022 Asano Physics Club, All Rights Reversed.</p></footer></main></body></html>