<!doctype html><html lang=ja><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=description content="高2の部員が、なんとC++のコンパイラを自力で実装。ポインタや関数などを含む基本的な機能を完成させ、記事内では比較演算子の実装までを解説しています。"><meta name=viewport content="width=device-width,initial-scale=1"><link rel=stylesheet href=/css/styles.css><link rel=icon href=/image/favicon.svg type=image/svg+xml><link rel="icon alternate" href=/image/favicon.ico><meta property="og:site_name" content="浅野学園物理部"><meta property="og:url" content="https://asanobuturi.github.io/document/2021/10/index.html"><meta property="og:title" content="自作コンパイラを実装してみた｜浅野学園物理部"><meta property="og:description" content="高2の部員が、なんとC++のコンパイラを自力で実装。ポインタや関数などを含む基本的な機能を完成させ、記事内では比較演算子の実装までを解説しています。"><meta property="og:type" content="website"><meta property="og:image" content="https://asanobuturi.github.io/document/2021/10/thumbnail.jpg"><meta name=twitter:card content="summary_large_image"><meta name=twitter:site content="@Uchi54_APC"><script src=/general.js></script><link rel=stylesheet href=/css/article.css><link rel=stylesheet href=/css/tableOfContents.css><script src=https://kit.fontawesome.com/1e291c4f9b.js crossorigin=anonymous></script><title>自作コンパイラを実装してみた｜浅野学園物理部</title><script type=text/javascript async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS_CHTML"></script><link rel=stylesheet href=/css/highlight.css></head><body><div id=nav-drawer><input id=nav-input type=checkbox class=nav-unshown>
<label id=nav-open for=nav-input><span class="bar bar1"></span><span class="bar bar2"></span><span class="bar bar3"></span><span class=menu>MENU</span>
<span class=close>CLOSE</span></label>
<label id=nav-close for=nav-input></label><div id=nav-content><a href=/index.html><img loading=lazy src=/image/favicon.svg id=nav-logo alt=浅野学園物理部></a>
<a class=nav-link href=/index.html>ホーム</a>
<a class=nav-link href=/about/index.html>物理部とは</a>
<a class="nav-link isActive" href=/document/index.html>部誌</a>
<a class=nav-link href=/game/index.html>ゲーム</a>
<a class=nav-link href=/blog/index.html>ブログ</a>
<a class=nav-link href=/electronic/index.html>電工の部屋</a><div class=nav-separator></div><a class=nav-link href=/credit/index.html>クレジット(ライセンス)</a></div></div><main><div id=main><div class=documentcontent><div id=breadcrumbs><a href=/index.html><img src=/image/icons/home-solid.svg class=inline-image>ホーム</a>
<img src=/image/icons/angle-right-solid.svg class=inline-image><a href=../../index.html>部誌</a>
<img src=/image/icons/angle-right-solid.svg class=inline-image><a href=../index.html>2021年度部誌</a>
<img src=/image/icons/angle-right-solid.svg class=inline-image><a href=./index.html>自作コンパイラを実装してみた</a></div><header class=documenttitle><h1 id=title>自作コンパイラを実装してみた</h1><p class=author><img src=/image/icons/user-edit-solid.svg class=inline-image>中野(高2)</p><div class=share><a href="https://twitter.com/share?ref_src=twsrc%5Etfw" class=twitter-share-button data-related=Uchi54_apc data-lang=ja data-show-count=false>Tweet</a>
<script async src=https://platform.twitter.com/widgets.js></script></div></header><div class=document><h2 id=はじめに>はじめに</h2><p>こんにちは、高二の中野です。今回の部誌では、コンパイラについて紹介してみたいと思います！自分自身昔からコンパイラに対して「難しそう」みたいな偏見を抱えていて全く触れてこなかったのですが、ふとしたきっかけで自作Cコンパイラについて体系的にまとめているサイト(参考文献に載せておきます)を見かけて覗いたところ、「意外といけそう」と思ったので軽く始めてみたらハマってしまったという次第です。ところどころ至らない点があると思うので、もし不明な点や疑問があればこのメールアドレス( <code>s2017197@asano.ed.jp</code> )に連絡してください。</p><h2 id=対象読者>対象読者</h2><p>C++, Pythonなどのメジャー言語で基礎的なコードが書ける人。ある程度人のコードが読める人。今回の部誌は扱う内容がかなり学問的というか高度なので、細かいプログラミング言語の文法などは説明しないのでご了承ください。同様に小学生がこれを読むのもあまりおすすめしません。受験勉強してください。逆にこの条件から外れた方々にとっては割と楽しめる内容かと思います。わからない用語・関数などが出てきたら適宜自分で調べてみてください。コーディングにおいて自分のほしい情報を限られた時間でインターネット等で見つけるのは大事な能力です。ちなみに私はC++のリファレンスを参照する際には cpprefjp(<a href=https://cpprefjp.github.io>https://cpprefjp.github.io</a>)を主に使っています。</p><h2 id=コンパイラとはなんぞや>コンパイラとはなんぞや</h2><p>ではここから実際にコンパイラとは何かを説明しましょう。
Wikipediaにはこのように書いてあります。</p><blockquote><p>コンパイラ（英: compiler）は、コンピュータ・プログラミング言語の処理系（言語処理系）の一種で、高水準言語によるソースコードから、機械語あるいは元のプログラムよりも低い水準のコードに変換（コンパイル）するプログラムである。</p></blockquote><p>有名な話かもしれませんが、コンピュータは0と1の羅列(2進数)をデータとして扱い、それをもとに計算などを実行しています。要は、コンピュータは<code>0010100110011001010101000</code>などのような我々人間にとって一見摩訶不思議に見える数字の羅列を用いています。一方、我々は普段日本語や英語などの自然言語を用いています。この人間とコンピュータの通訳係となってくれるのがコンパイラです。大半のプログラミング言語は人間にとってある程度の可読性が担保されています。もちろん、我々はコンピュータを利用するためにさっきの0と1の羅列を自分でキーボードで打つわけにはいけませんよね？その、<strong>割と人間寄りいわば自然言語寄りのプログラミング言語をコンピュータが理解できるように0と1の羅列に変換するのがまさにコンパイラの仕事なのです。</strong> コンパイラの仕組みを理解することできっとあなたはコンピュータと、より親しくなれるでしょう！</p><h2 id=コンパイルの手順>コンパイルの手順</h2><p>前章ではコンパイラの概要について説明しました。ここから詳しい話に移りたいと思います。まず簡潔に言うと、コンパイラは以下の4つのフェーズを踏んで実行されます。</p><p>1.<strong>字句解析</strong><br>　　　↓<br>2.<strong>構文解析</strong><br>　　　↓<br>3.<strong>アセンブリコードの生成</strong><br>　　　↓<br>4.<strong>生成したアセンブリコードをバイナリに変換する</strong><br></p><p>これだけだと分かりづらいと思うので具体例を出して説明します。今 <code>int main(){return 0;}</code> というC言語のソースコードをコンパイルしたいとします。当然コンパイラへの入力形式は <strong>文字列</strong> です(C++で扱うとしたら <code>const char*</code>や<code>std::string</code>のような型を用いるでしょう)。しかしコンパイラからしてみると、文字列の状態だと大変扱いづらいのです。プログラムによっては<code>int main () { return 0; /*hogehoge*/}</code> のような本来コンパイルする際には不要な空白やコメントがついている場合もあります。それを除去してよりソースコードの本質を抽出するような処理が1番目の字句解析です。このプログラムの場合、ソースファイルは [<code>int</code>,<code>main</code>, <code>(</code>, <code>)</code>, <code>{</code>, <code>return</code>, <code>0</code>, <code>;</code>, <code>}</code>] という一つずつが意味を持った <strong>字句(トークン)</strong> の配列に変換され、コメントや空白なども全て無視されます。こうすることで、2番目以降の処理が格段にやりやすくなるのです。次にこのトークン配列を <strong>構文解析木(AST)</strong> という <strong>木構造</strong> に変換します(なぜこのようにする必要があるのかは後ほど説明します)。この工程を文字通り　<strong>構文解析</strong>と呼びます。そして、その構文解析木を元にアセンブリコードを生成して、そのコードを機械語(バイナリ)に変換(アセンブルといいます)すればコンパイラの仕事は終わりです。字句解析の過程は比較的に簡単なので、ページ数的に <strong>ここでは省略したいと思います</strong>。では次章からさっそく構文解析から実装していきましょう！ちなみに今回はすべてC++で実装しています。</p><h2 id=開発環境>開発環境</h2><p>今回私はVisual Studioでコーディング&ビルドし、生成したアセンブリコードは <code>WSL(Windows Subsystem Linux)</code> というWindowsマシン上でLinux(Ubuntu)が動く的な仮想環境上で実行ファイルにアセンブルしました。ちなみにビルドする際は <code>x86</code> ではなく <code>x64</code> でビルドしてください。 <code>x86</code> だとなぜか <code>WSL</code> の呼び出しに失敗します。</p><h2 id=構文解析>構文解析</h2><p><code>gcc</code> などの我々が普段書くようなコードをコンパイルしてくれるコンパイラの全てをここで実装するのは到底不可能なので、 <strong>まず最初に、四則演算をしてくれるコンパイラを作成したいと思います</strong>。例を上げると、 <code>1 + 2 * (3 + 4)</code> という文字列を入力すると <code>15</code> を返してくれるアセンブリコードを出力するプログラムを作ります。そして、今章では前章で扱ったフローのうち、構文解析について説明します。ちなみにmain関数にコンパイラのすべての要素を実装するのは可読性的にあまりよろしくないので、構文解析は <code>Parse</code> という専用の関数に実装し、それをmain関数で呼ぶ形式を取りたいと思います。また構文解析の段階では字句解析は終了している(<code>Tokenize</code>関数で実装している)ので、以下に示す <code>Token</code> クラスのベクターである <code>std::vector&lt;Token> tokens;</code> が既に存在しているという前提で話を進めます。ちなみにこれからはソースコードは全体ではなく変更部分だけを載せたいと思います。</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">16
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">17
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">18
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">19
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">20
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">21
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">22
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">23
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">24
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">25
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">26
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">27
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">28
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">29
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">30
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">31
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">32
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">33
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">34
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">35
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">36
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">37
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">38
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">39
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">40
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">41
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#75715e>//予め必要なファイルはここでインクルードする
</span><span style=color:#75715e></span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iostream&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;string&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;vector&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;memory&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;functional&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;fstream&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;algorithm&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;cassert&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e></span>
<span style=color:#75715e>//トークンの種類を表す列挙型
</span><span style=color:#75715e></span><span style=color:#66d9ef>enum</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>TOKENTYPE</span> {
    NUMBER, <span style=color:#75715e>//数字リテラルトークンを表す
</span><span style=color:#75715e></span>    CHARACTER, <span style=color:#75715e>//文字リテラルトークンを表す
</span><span style=color:#75715e></span>    STRING, <span style=color:#75715e>//文字列リテラルトークンを表す
</span><span style=color:#75715e></span>    SYMBOL, <span style=color:#75715e>//(, ), {, }などの記号トークンを表す
</span><span style=color:#75715e></span>    KEYWORD, <span style=color:#75715e>//intやreturnなどの予約語トークンを表す
</span><span style=color:#75715e></span>    IDENTIFIER, <span style=color:#75715e>//変数名などの識別子トークンを表す
</span><span style=color:#75715e></span>    NONE <span style=color:#75715e>//トークンが初期化されてない状態を表す
</span><span style=color:#75715e></span>};

<span style=color:#75715e>//トークンクラス
</span><span style=color:#75715e></span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Token</span> {
<span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
    TOKENTYPE type;
    std<span style=color:#f92672>::</span>string string;
};

std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>Token<span style=color:#f92672>&gt;</span> tokens;

<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>Tokenize</span>(){ ... } <span style=color:#75715e>//ここで字句解析を行う。字句解析の結果はtokensに保存される。本誌では扱わない。
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>Parse</span>(){ ... } <span style=color:#75715e>//ここで構文解析を行う。本章はこの関数に焦点を当てる。
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>GenerateAssembly</span>(){ ... }<span style=color:#75715e>//ここでアセンブリコードを生成する。8章ではこの関数に焦点を当てる
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(){
    Tokenize();
    Parse();
    GenerateAssembly();
}
</code></pre></td></tr></table></div></div><p>さて、本格的にコーディングを始める準備が整いました。ここで先程提示した <code>1 + 2 * (3 + 4)</code> という数式に考えてみましょう。もし、この世の数式が数字と <code>+</code> と <code>-</code> のみで表されていたらその値を計算するのはとても簡単です。前から数字を読んでいって <code>+</code> で繋がれていたら前の結果にその値を足す、 <code>-</code> であればその値を引く、というふうにすることで楽に実装できます。問題を複雑にしているのは <code>+</code> や <code>-</code> ではなく <code>*</code> や <code>/</code> であるということになります。そして、ここで大事なのは数式には文法があるということです(コンパイル実装においてさらに広義的に考えると、プログラムのソースコードにも文法があるということになります)。ルールがなかったら数式をどの人が見ても普遍的に認識することができません。ロシア語圏では数式はこのように理解されて、フランス語圏ではまた別にこのように理解されて～～ということはありえないのです(自然言語にはそういうのは多々ありますが)。また、もちろんルールが存在するということはそのルールを記述する専用のフォーマットが存在するということです。有名どころでいうとBNF記法(バッカス・ナウア記法)などがあります。Wikipediaの記事(<code>https://ja.wikipedia.org/wiki/バッカス・ナウア記法</code>)を見ると、アメリカでの住所表記のルールがBNF記法で記述されていて面白かったです。このように、BNF記法は広範に及んで適用可能な記法なので昔からずっと使われているのだと思われます。そして、数式というのもまたBNF記法の適用範囲内なのです。今回はBNF記法を拡張したEBNF記法で数式の文法のルールを書いてみます。それが <code>ソース2</code> です。</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback>Expr = Mul (&#34;+&#34; Mul | &#34;-&#34; Mul)*
Mul = Primary (&#34;*&#34; Primary | &#34;/&#34; Primary)*
Primary = Num | &#34;(&#34; Expr &#34;)&#34;
Num = &#34;0&#34; | &#34;1&#34; | &#34;2&#34; | &#34;3&#34; | &#34;4&#34; | &#34;5&#34; | &#34;6&#34; | &#34;7&#34; | &#34;8&#34; | &#34;9&#34;
</code></pre></td></tr></table></div></div><p>このEBNF記法ではnumが数字リテラル(0~9)を表しており、どの数式もこのような入れ子構造(木構造)で表現することができ、我々が小学校で習った四則演算の順序としっかり一致しています。以下に示す木構造は、式<code>1 + 4(2 + 3) - 5</code> を <code>ソース2</code> のEBNF記法に基づいて分解したものになります。BNFなどの生成規則に基づいて生成された木構造を <strong>構文解析木</strong> といいます。</p><p><img src=%E6%A7%8B%E6%96%87%E8%A7%A3%E6%9E%90%E6%9C%A81.png alt=構文解析木1></p><p>一見なんだか難しそうな気がしますが、この木構造もちゃんと上の規則に従っています。そして、プログラミング言語もこれらの規則が複雑になっているだけでちゃんとコーディング時の文法ルールもBNFで記述することができ、ソースコード自体も構文解析木に落とし込むことができます。4章で私はトークン列は構文解析木に変換する必要があると言いました。木構造の特徴として再帰的処理(深さ優先探索など)が行いやすいというのがあります。このことこそがトークン列を構文解析木に変換する意義の一つです。何千行もある膨大なソースファイルを正確にアセンブリに変換するには再帰的処理を行うことで明快に実装することができるのです。
ただしExpr, Mulなどのノードは実際のコンパイラ実装には不必要なのでそれらのノードを削った木構造のことを <strong>抽象構文木</strong> といいます。以下に示す木構造は上の構文解析木を抽象構文木に加工したものです。</p><p><img src=%E6%8A%BD%E8%B1%A1%E6%A7%8B%E6%96%87%E6%9C%A81.png alt=抽象構文木1></p><p>では、これからいよいよ実際に抽象構文木を実装していきます。木構造のノードを表すのには基本ポインタ型を用いますが、実装言語がC++なのでその特徴を生かしてメモリ解放などをいちいち気にしなくて済むスマートポインタである <code>std::shared_ptr</code> を使いたいと思います。いちいちこの長い型名をタイプするのは面倒なので、グローバル空間で最初にエイリアス宣言をします。</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback>template&lt;class T&gt;
using Ptr = std::shared_ptr&lt;T&gt;;
</code></pre></td></tr></table></div></div><p>すると、それぞれのノードの型は次のように表すことができます。</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">16
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">17
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">18
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">19
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">20
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">21
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp>
<span style=color:#75715e>//ノードの種類を表す列挙型
</span><span style=color:#75715e></span><span style=color:#66d9ef>enum</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>NODETYPE</span>{
    ADD, <span style=color:#75715e>// +ノードを表す
</span><span style=color:#75715e></span>    SUB, <span style=color:#75715e>// -ノードを表す
</span><span style=color:#75715e></span>    MUL, <span style=color:#75715e>// *ノードを表す
</span><span style=color:#75715e></span>    DIV, <span style=color:#75715e>// /ノードを表す
</span><span style=color:#75715e></span>    NUMBER,<span style=color:#75715e>// 数字リテラルの末端ノードを表す
</span><span style=color:#75715e></span>    NONE <span style=color:#75715e>//無効なトークンを表す
</span><span style=color:#75715e></span>};

<span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Node</span>{
<span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
    Ptr<span style=color:#f92672>&lt;</span>Node<span style=color:#f92672>&gt;</span> lhs, rhs;
    NODETYPE type;
    <span style=color:#66d9ef>int</span> num; <span style=color:#75715e>//数字ノードの時に使う
</span><span style=color:#75715e></span>    Node(){
        type <span style=color:#f92672>=</span> NODETYPE<span style=color:#f92672>::</span>NONE;
        num <span style=color:#f92672>=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>;
    }
};
</code></pre></td></tr></table></div></div><p>四則演算の場合抽象構文木は完全二分木なので、<code>lhs</code> と <code>rhs</code> で自分のノードの子ノードを表します。次にノードの追加などのユーティリティ関数を実装しようと思います。また、グローバル空間が汚染されないために構文解析で用いる関数群は全てラムダ式として <code>Parse</code> 関数のスコープ内で宣言します。またラムダ式の場合、宣言と初期化を分けられないので前方宣言の必要がある場合は <code>std::function</code> を使います。細かい仕様は各自リファレンスで調べてください。ユーティリティ関数を実装したのが <code>ソース4</code> です。一応述べておくと、以下のコードは全て <code>Parse</code> 関数のスコープ内に記述されます。</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">16
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">17
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">18
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">19
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">20
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">21
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">22
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">23
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">24
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">25
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">26
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">27
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">28
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">29
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">30
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback>
size_t token_pos = 0; //今見ているトークンの番号

//もし今見ているトークンが引数の文字列と一致するならtoken_posをインクリメントしてtrueを返す
auto ConsumeByString = [&amp;](std::string str)-&gt;bool {
    if (token_pos &gt;= tokens.size())return false;
    if (tokens[token_pos].string == str) {
        ++token_pos;
        return true;
    }
    return false;
};

//lhsとrhsを子ノードに持つノードを返す
auto MakeBinaryNode = [](NODETYPE type, Ptr&lt;Node&gt; lhs, Ptr&lt;Node&gt; rhs)-&gt;Ptr&lt;Node&gt; {
    Ptr&lt;Node&gt; node = std::make_shared&lt;Node&gt;();
    node-&gt;type = type;
    node-&gt;lhs = lhs;
    node-&gt;rhs = rhs;
    return node;
};

//末端ノード(数字リテラルのノード)を返す関数
auto MakeNum = [](int num)-&gt;Ptr&lt;Node&gt; {
    Ptr&lt;Node&gt; node = std::make_shared&lt;Node&gt;();
    node-&gt;num = num;
    node-&gt;type = NODETYPE::NUMBER;
    return node;
};

</code></pre></td></tr></table></div></div><p><code>ソース4</code> はやることをただ実装しているだけなのでコードを読み解くのはそこまで難しくないと思います。では、いよいよ構文木の真髄を実装します。まず、与えられたトークン列全体は <code>ソース2</code> における<code>Expr</code> に分類可能です。逆に与えられたトークン列が式(Expr)として解釈できなかったらおかしいですよね？だって、今は式がコンパイラの入力として与えられているのですから。また、<code>Expr</code> は式全体を評価する以外にも <code>Primary = Num | "(" Expr ")"</code> という生成規則がある以上、別のところで例えば、より木が深くなった部分でも評価する必要があります。最も有名かつ手軽な手法が <code>Expr</code>, <code>Mul</code>, <code>Primary</code>, <code>Num</code> などのそれぞれのEBNFの要素を関数として実装する手法です。こうすることで再帰的な処理ができ、比較的楽に実装することができます。こうすることでそれぞれの生成規則の要素の相互関係を関数呼び出しで対応することができます。この手法を <strong>再帰下降構文解析</strong> といいます。式全体を <code>Expr</code> と決めつけてそのあとによりミクロな視座で部分を評価して木を伸ばすという性質を考えればこの名前の由来も合点がいきます。次の <code>ソース4</code> がそれぞれのEBNFの要素を関数として実装したコードになります。ひと目見ただけじゃ本当にそれが機能するかどうかわからないと思いますが、この後に実際の例を用いて説明するので安心してください。また、これらの関数の実装の本質は <code>ソース2</code> の生成規則なので適宜 <code>ソース2</code> を参照してください。</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">16
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">17
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">18
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">19
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">20
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">21
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">22
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">23
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">24
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">25
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">26
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">27
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">28
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">29
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">30
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">31
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">32
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">33
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">34
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">35
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">36
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">37
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">38
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">39
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">40
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">41
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback>std::function&lt;Ptr&lt;Node&gt;(void)&gt; Expr, Mul, Primary; //これらはお互いに他の関数を呼び出し合うこともあるので前方宣言をしておきます

Expr = [&amp;]()-&gt;Ptr&lt;Node&gt;{
    //Exprは1個以上のMulが+もしくは-で結合されている

    Ptr&lt;Node&gt; node = Mul(); //この段階で1つのMulを読み込んだので後は+もしくは-が存在すればそのトークンを消費してMulを読み込む(5-1)
    for(;;){
        if(ConsumeByString(&#34;+&#34;))node = MakeBinaryNode(NODETYPE::ADD, node, Mul());//(5-3)
        else if(ConsumeByString(&#34;-&#34;))node = MakeBinaryNode(NODETYPE::SUB, node, Mul());
        else break;
    }
    return node;
};

Mul = [&amp;]()-&gt;Ptr&lt;Node&gt;{
    //Mulは1個以上のPrimaryが*もしくは/で結合されている
    Ptr&lt;Node&gt; node = Primary();//(5-2)
    for(;;){
        if(ConsumeByString(&#34;*&#34;))node = MakeBinaryNode(NODETYPE::MUL, node, Primary());
        else if(ConsumeByString(&#34;/&#34;))node = MakeBinaryNode(NODETYPE::DIV, node, Primary());
        else break;
    }
    return node;
};

Primary = [&amp;]()-&gt;Ptr&lt;Node&gt;{
    //Primaryは()でくくられたExprか、数字リテラルである
    Ptr&lt;Node&gt; node;
    if(ConsumeByString(&#34;(&#34;)){
        //もし(があったらそれはExprであるということ
        node = Expr();
        ConsumeByString(&#34;)&#34;);
    }else{
        //もし違ったら数字リテラルである
        assert(tokens[token_pos].type == TOKENTYPE::NUMBER); //(注)このようなアサーションを入れといたほうがデバッグなどがしやすいです
        node = MakeNum(std::stoi(tokens[token_pos].string));
        ++token_pos;
    }
    return node;
};

</code></pre></td></tr></table></div></div><p>これらがそれぞれのEBNFの要素を関数として実装した結果です。また式全体すなわち与えられたトークン列は <code>Expr</code> としてみなすことができるので、最初に <code>Expr</code> 関数を呼び出します。それが <code>ソース6</code> です。</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback>Ptr&lt;Node&gt; program = Expr(); //全体の抽象構文木はprogramに格納される
</code></pre></td></tr></table></div></div><p><img src=%E6%88%BB%E3%82%8A%E5%80%A4%E3%81%AE%E9%96%A2%E4%BF%82.png alt=戻り値の関係(ソース7)>{width=130 .img-right}</p><p>これを提示されただけではよくわからないと思うので具体例を出して一緒に考えてみましょう。今回は <code>4 * 2 + 3 * 7</code> という式について考えてみます。 まず <code>ソース6</code> より <code>Expr()</code> が呼び出されます。そして今度は <code>Expr()</code> 内で <code>Mul()</code> が呼ばれます(<code>ソース5</code>の<code>5-1</code>のところ)。次に <code>Mul()</code> 内で <code>Primary()</code> が呼ばれます(<code>ソース5</code>の<code>5-2</code>のところ)。これらの呼び出し関係を図で表すと <code>ソース7</code> のようになります。</p><p>画像内の矢印は戻り値を表しています。それぞれの関数は戻り値が <code>Ptr&lt;Node></code> のポインタ型なので木もしくはノード単体を表していることになります。(1)では <code>Primary</code> の実装を見ると数字リテラルのノードが帰ることになります。それをビジュアル化すると <code>ソース8</code> になります。</p><p><img src=(1).png alt=ソース8></p><p>また式を見ると <code>4</code> と <code>2</code> が <code>*</code> で結合されているので(2)では以下のような木構造が返されることになります。</p><p><img src=(2).png alt=ソース9></p><p>この段階でようやく最初に呼ばれていた <code>Expr</code> 関数に戻りました。この時点で式全体 <code>4 * 2 + 3 * 7</code> のうちの <code>4 * 2</code> までが処理されたことになります。またその後には <code>+</code> が続いているので、<code>ソース5</code>の<code>5-3</code>よりもう一度 <code>Mul()</code> が呼ばれることになります。またそこで以下のような木構造が返されます。</p><p><img src=(3).png alt=ソース10></p><p>そして、<code>Expr</code> 関数内の <code>node = MakeBinary(NODETYPE::ADD, node, Mul());</code> という処理によりこれらの２つの木が <code>+</code> 演算子のノードで結合されることになります。その結果が以下になります。</p><p><img src=(4).png alt=ソース11>{width=500}</p><p>これで式全体 <code>4 * 2 + 3 * 7</code> の読み込みが完了しました。これ以降はもう <code>+</code> も <code>-</code> も存在しないのでここで <code>Expr</code> の処理は打ち切られ上の木構造がそのまま <code>program</code> 変数に格納されることになります。これによってちゃんと式全体がEBNFの文法規則に従って抽象構文木に変換されたことになります。これが構文解析の全てです。後はEBNFの文法規則が複雑になるだけで、「それぞれの要素を関数として実装して再帰的な処理をする」という今までやってきた大まかな流れは変わりません。現に私が今実装しているコンパイラもこの流れを変えていません。みなさん、ここまでお疲れ様でした。次章ではこの章で作られた抽象構文木をもとに実際にアセンブリコードを出力してみましょう！</p><h2 id=アセンブリで四則演算>アセンブリで四則演算</h2><p>本章では前章で構築した構文解析木をもとにアセンブリコードの出力を目標に実装していきます。
まずはスタックという概念について説明します。おそらくプログラマーの大半はスタックやキューといった言葉は一度くらい聞いたことがあると思います。Wikipediaにはスタックについてこのように書かれています。</p><blockquote><p>スタックは、コンピュータで用いられる基本的なデータ構造の1つで、データを後入れ先出し（LIFO: Last In First Out; FILO: First In Last Out）の構造で保持するものである。抽象データ型としてのそれを指すこともあれば、その具象を指すこともある。</p></blockquote><p>スタックとは誤解を恐れずに言うと、値を追加(Push)したり、コンテナ上の要素を削除(Pop)することができるデータ構造です。ここで重要なのは、要素が削除される場所が一意に定まるということです。以下のような{2, 3, 5, 7}と表されるスタックを考えてみてください。(ソース12)</p><p>スタックでは、値を追加するときは図の(1)方向でしか追加することができず、値を削除するときも基本的に(1)側にある要素しか削除しかできません。またキューの場合には値を削除するときは(2)側の要素しか削除できません。そしてコンテナの途中に値を割り込んで追加することもできません。これを不便に思うかもしれませんが、このことこそがスタックそしてキューの最大の特徴なのです。
次になぜコンパイラ作成の過程でスタックの概念が登場するのかを説明します。まず、前提としてどんなに複雑な式でも2項の計算の組み合わせとして計算することができます。前章で扱った <code>4 * 2 + 3 * 7</code> という式で考えてみましょう。
まず最初に <code>4 * 2</code> を計算して <code>8</code> という結果を得ます。次に <code>3 * 7</code> を計算して <code>21</code> という結果を得ます。そして最後に計算結果である <code>8 + 21</code> を計算して <code>29</code> という式全体の値を計算することができました。これが私が先程言った「どんなに複雑な式でも2項の計算の組み合わせとして計算」の意味です。
今、前章で扱った抽象構文木を思い出してみてください。あれらも、もし自分のノードが演算子のノードだったら必ず2つのノードを子として保持していますよね？必ずしもその子ノードが数字リテラルであるとは限りませんが。このような背景から式全体を計算するには、「数字リテラルすなわち末端ノードが現れるまで走査し、２つの子ノードを親ノードの演算子ノードに従って計算しそれを上に伝播すればよい」という方針が立ちます。ここでこの伝播を表現するのにスタックを用いるのです。では先程と同様に <code>4 * 2 + 3 * 7</code> の例で考えてみましょう。まず、構文木の頂点を起点として深さ優先探索(Depth-First Search)をします(深さ優先探索を知らない人は適当に各自で調べてください)。そして、子ノードがもし数字リテラルであればスタックにプッシュします。そうすることで <code>*</code> ノードを探索した後、スタックは次のようになります。</p><p><img src=(5).png alt=ソース12>{width=100 .img-left}</p><p><img src=(6).png alt=ソース13></p><p>そしてこの時、自分自身のノードは <code>*</code> であるので、スタックから2つの値をポップしてそれらに <code>*</code> 演算を施した結果を再度スタックにプッシュします。そして次は<code>ソース14</code>で赤で囲った部分木にも同様の処理を施してあげるとスタックは <code>ソース15</code> のようになります。</p><p><img src=(7).png alt=ソース14>{width=100%}</p><p><img src=(8).png alt=ソース15></p><p>そして、赤で囲った部分木の親は <code>*</code> なのでスタックから2つの値を同様にポップして計算した結果をスタックにプッシュするとスタックは以下になります。</p><p><img src=(9).png alt=ソース16></p><p>最後に、抽象木全体の頂点は <code>+</code> ノードなのでスタックに残っている <code>8</code> と <code>21</code> に <code>+</code> 演算を施した結果をスタックにプッシュして次のような結果を得られます。</p><p><img src=(10).png alt=ソース17></p><p>これが式全体の演算結果を抽象構文木に基づいて計算するアルゴリズムです。そしてこのアルゴリズムをアセンブリで表現する必要、すなわちその演算をするアセンブリコードを生成する必要があるのですが、それを実装するには多少のアセンブリの知識が必要なのでそれについてまず説明します。</p><p>そもそもx86-64のCPUにはスタック上で直接値の計算ができません。基本x86-64のCPUはレジスタと呼ばれるメモリよりも高速にアクセスが可能である記憶領域においての演算しか行いません。このコンピュータのことを <strong>レジスタマシン</strong>　と言います。 なので、私達は先程紹介したスタックの概念とレジスタの演算を結びつける必要があります。また、レジスタにはそれぞれ名前がついており、それぞれの役割が暗黙的に割り当てられています。以下に示す表が今回使うレジスタたちです。</p><table><thead><tr><th style=text-align:left>レジスタ</th><th style=text-align:left>役割</th></tr></thead><tbody><tr><td style=text-align:left><code>rax</code></td><td style=text-align:left>汎用レジスタ</td></tr><tr><td style=text-align:left><code>rdi</code></td><td style=text-align:left>汎用レジスタ</td></tr><tr><td style=text-align:left><code>rsp</code></td><td style=text-align:left>スタックトップのアドレスを保持しているレジスタ</td></tr></tbody></table><p>汎用レジスタとは、用途が特に定まっておらずユーザーが様々な演算する際に値を記憶しておけるレジスタのことです。</p><p>では次にレジスタに対して演算を施すCPUの命令を紹介します。アセンブリのコードはこれらの命令の連続であると考えることができます。</p><table><thead><tr><th style=text-align:left>命令</th><th style=text-align:left>命令の意味</th></tr></thead><tbody><tr><td style=text-align:left><code>pop r1</code></td><td style=text-align:left>スタックから要素を一つポップしてその値をレジスタr1に保存する</td></tr><tr><td style=text-align:left><code>push r1</code></td><td style=text-align:left>レジスタr1に格納されている値をスタックにプッシュする(レジスタではなく <code>1</code> や <code>15</code> などの即値でもよい)</td></tr><tr><td style=text-align:left><code>add r1, r2</code></td><td style=text-align:left>r1とr2にそれぞれ格納されている値を足してその結果をr1に保存する</td></tr><tr><td style=text-align:left><code>sub r1, r2</code></td><td style=text-align:left>r1に格納されている値からr2に格納されている値を引いてその結果をr1に保存する</td></tr><tr><td style=text-align:left><code>imul r1, r2</code></td><td style=text-align:left>r1とr2にそれぞれ格納されている値を掛け合わせてその結果をr1に保存する</td></tr><tr><td style=text-align:left><code>ret</code></td><td style=text-align:left>raxレジスタに保存されている値を自分の関数の戻り値としてリターンする</td></tr></tbody></table><p>割り算の命令だけは書かなかったのですが、これはなぜかというと除算命令は他の四則演算と仕様が違うので同列に書けなかったからです。除算命令を実装したいときは代わりに以下のコードを使ってください。</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plaintext data-lang=plaintext>cqo
idiv rdi
</code></pre></td></tr></table></div></div><p>これの詳細を知りたい人はググってください。</p><p>これで準備が整いました。実際に <code>4 * 2 + 3 * 7</code> を計算するアセンブリコードを書いてみましょう。以下に示すのはあくまでアセンブリのコードであり、今まで紹介してきたC++のコードとは全く別物なので勘違いしないでください。</p><p><code>ソース18</code></p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">16
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">17
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">18
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">19
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">20
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">21
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">22
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">23
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">24
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">25
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">26
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">27
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">28
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">29
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">30
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">31
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=color:#a6e22e>.intel_syntax</span> <span style=color:#66d9ef>noprefix</span>
<span style=color:#a6e22e>.global</span> <span style=color:#66d9ef>main</span>
main:
    <span style=color:#75715e>#アセンブリの場合エントリポイントはmainなのでその中で処理を書く
</span><span style=color:#75715e></span>    <span style=color:#a6e22e>push</span> <span style=color:#ae81ff>4</span>
    <span style=color:#a6e22e>push</span> <span style=color:#ae81ff>2</span>

    <span style=color:#a6e22e>pop</span> <span style=color:#66d9ef>rdi</span>
    <span style=color:#a6e22e>pop</span> <span style=color:#66d9ef>rax</span>
    <span style=color:#75715e>#この段階でrdiには2, raxには4が格納されている
</span><span style=color:#75715e></span>
    <span style=color:#a6e22e>imul</span> <span style=color:#66d9ef>rax</span>, <span style=color:#66d9ef>rdi</span> <span style=color:#75715e>#ここで4 * 2の演算を実行して8がraxに新たに保存される
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>push</span> <span style=color:#66d9ef>rax</span> <span style=color:#75715e>#そして8をスタックにプッシュ
</span><span style=color:#75715e></span>
    <span style=color:#a6e22e>push</span> <span style=color:#ae81ff>3</span>
    <span style=color:#a6e22e>push</span> <span style=color:#ae81ff>7</span>
    <span style=color:#75715e>#この段階でスタックは{ 8, 3, 7 }という並びになっている
</span><span style=color:#75715e></span>
    <span style=color:#a6e22e>pop</span> <span style=color:#66d9ef>rdi</span>
    <span style=color:#a6e22e>pop</span> <span style=color:#66d9ef>rax</span>
    <span style=color:#75715e>#この段階でrdiには7, raxには3が格納されています
</span><span style=color:#75715e></span>
    <span style=color:#a6e22e>imul</span> <span style=color:#66d9ef>rax</span>, <span style=color:#66d9ef>rdi</span> <span style=color:#75715e>#ここで3 * 7の演算を実行して21がraxに新たに保存される
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>push</span> <span style=color:#66d9ef>rax</span> <span style=color:#75715e>#21をスタックにプッシュ
</span><span style=color:#75715e></span>    <span style=color:#75715e>#この時点でスタックは{8, 21}という並びになっている
</span><span style=color:#75715e></span>
    <span style=color:#a6e22e>pop</span> <span style=color:#66d9ef>rdi</span>
    <span style=color:#a6e22e>pop</span> <span style=color:#66d9ef>rax</span>
    <span style=color:#a6e22e>add</span> <span style=color:#66d9ef>rax</span>, <span style=color:#66d9ef>rdi</span> <span style=color:#75715e>#ここで8 + 21 = 29が計算され、結果がraxに保存される
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>ret</span>

</code></pre></td></tr></table></div></div><p>はい、ここまでで計算結果がraxレジスタに保存されるという状態を実現できました。そしてこのコードでは <code>ret</code> 命令を追加してmain関数の戻り値として計算結果を返すようにしました。では実際にWSLのターミナルで本当に計算結果が帰ってくるのか確認してみましょう。
では、上記のコードを <code>test.s</code> として保存してください。そしてこのアセンブリコードを <code>cc -o test test.s</code> というコマンドでアセンブルして、 <code>test</code> という実行ファイルを生成します。その後、 <code>./test</code> でアセンブルした実行ファイルを実行します。 最後に <code>echo $?</code> を実行します。このコマンドは直前に実行したプログラムの戻り値を表示するコマンドです。
これらをWSL上で実行すると、なんと、実際に29が表示されました！
自分のプログラムしたものがこうやって形として現れると嬉しいですよね。</p><p><img src=result.png alt=ソース19>{width=100%}</p><h2 id=アセンブリコードの自動生成>アセンブリコードの自動生成</h2><p>いよいよ、この章では6章と7章で学んだことを総動員してコンパイラ最後の砦、アセンブリコードの生成を実装していきます。これを実装すれば4章で説明したコンパイルのフローがすべて実装されたことになりました。後は構文などのプログラミング言語の要素を追加していくたびにこれらのフローのそれぞれの要素に追加で実装すればいいので、今章で大まかな全体としてのプログラムは完成することになります。まあこの後も様々困難が待ち構えているのですが。。。
ここではC++で前章で取り扱ったようなアセンブリコードを自動生成できるように実装をするのですが、大まかな方針は既に前章で紹介しています。「数字リテラルすなわち末端ノードが現れるまで走査し、２つの子ノードを親ノードの演算子ノードに従って計算しそれを上に伝播すればよい」ということです。これだけ言われてもやはりピンとこないと思うので丁寧に説明していきます。まず抽象構文木の特徴でもあるのですが、末端ノード以外、すなわち数字リテラル以外のノードは以下の構造をとっています。</p><p><img src=(11).png alt=ソース20></p><p>この場合、「自分」は子ノードを2つ持っているので必ず演算子ノードです。また「子1」、「子2」は数字ノードであるとは限りません。しかし、抽象構文木の頂点から深さ優先探索をして末端に行けば必ず「子1」と「子2」が数字ノードである部分木が1つ以上は存在します。なぜならどんなに複雑な式であっても必ず△ + △ のような2項からなる式の組み合わせにすぎないからです。これらのことから、もし子ノードが数字だったらその値をプッシュ、でなければ走査を続けるといったようなコードを実装すれば良いことになります。C++でこれを実装すると以下のようになります。</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">16
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">17
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">18
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">19
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">20
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">21
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">22
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">23
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">24
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">25
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">26
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">27
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">28
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">29
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">30
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">31
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">32
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">33
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">34
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">35
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">36
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">37
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">38
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">39
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">40
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">41
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">42
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">43
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">44
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">45
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">46
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">47
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">48
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">49
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">50
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">51
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">52
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">53
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">54
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">55
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">56
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">57
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">58
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">59
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback>
int GenerateAssembly(){

    //生成するアセンブリコードはここに格納する
    std::string res = &#34;.intel_syntax noprefix\n.global main\nmain:\n&#34;;

    //構文木を再帰的に走査する関数。再帰呼び出しをするのでこの命名をしたけどあんまり気に入ってない
    std::function&lt;void(Ptr&lt;Node&gt;)&gt; Recursive;

    Recursive = [&amp;](Ptr&lt;Node&gt; node){

        //もし今走査しているノードが数字ノードだったらその値をプッシュ
        if(node-&gt;type == NODETYPE::NUMBER){
            res += (&#34;\tpush &#34; + std::to_string(node-&gt;num) + &#34;\n&#34;);
            return;
        }

        //子ノードについても同様の走査をする
        Recursive(node-&gt;data[0]);
        Recursive(node-&gt;data[1]);

        //この段階で2つの値がスタックトップに存在しているはず。
        res += &#34;\tpop rdi\n&#34;;
        res += &#34;\tpop rax\n&#34;;

        switch(node-&gt;type){
        case NODETYPE::ADD:
            res += &#34;\tadd rax, rdi\n&#34;;
            break;
        case NODETYPE::SUB:
            res += &#34;\tsub rax, rdi\n&#34;;
            break;
        case NODETYPE::MUL:
            res += &#34;\timul rax, rdi\n&#34;;
            break;
        case NODETYPE::DIV:
            res += &#34;\tcqo\n&#34;;
            res += &#34;\tidiv rdi\n&#34;;
            break;
        }

        //最後に計算結果をプッシュ
        res += &#34;push rax\n&#34;;

    };

    //構文木の頂点から走査を始める
    Recursive(program);

    //計算結果をraxにポップする
    res += &#34;\tpop rax\n&#34;;

    //最後に計算結果をプログラムの戻り値として返す
    res += &#34;\tret\n&#34;;

    return 0;

}

</code></pre></td></tr></table></div></div><p>これで実際にプログラムに <code>4 * 2 + 1</code> という式を入力として与えて <code>std::cout &lt;&lt; res;</code> で生成されたアセンブリコードを実際に出力させると以下が得られます。</p><p><img src=(12).png alt=ソース22>{width=200}</p><p>これでようやくコンパイラの体裁をなして来ました。後は得られたアセンブリコードをコンパイラ内部でアセンブルして実行ファイルを生成するところまでやっていきましょう。以下のような関数を実装してください。</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">16
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">17
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">18
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">19
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">20
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">21
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">22
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">23
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback>
int Assemble() {
    //出力されたアセンブリコードをresult.sに保存する
    std::ofstream assembly_file{ &#34;result.s&#34; };
    assembly_file &lt;&lt; assembly_code;
    assembly_file.close();

    //result.sをバイナリファイルに変換する
    int res = system(&#34;wsl cc -o result result.s&#34;);

    //もしccコマンドが正常終了しなかったらエラーログを出す
    if (res != 0)std::cout &lt;&lt; &#34;Assembling didn&#39;t go well.\n&#34;;

    return 0;
}

int Run() {
    //resに式の演算結果が保存されるのでそれを出力
    int res = system(&#34;wsl ./result&#34;);
    std::cout &lt;&lt; res &lt;&lt; &#34;\n&#34;;
    return 0;
}

</code></pre></td></tr></table></div></div><p>このコードはコンパイラ実装の本流とは関係ないので説明は省略します。
よって、 <code>main</code> 関数内の関数呼び出しの順番は</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">7
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">8
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">9
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plaintext data-lang=plaintext>Tokenize
↓
Parse
↓
GenerateAssembly
↓
Assemble
↓
Run
</code></pre></td></tr></table></div></div><p>となります。
ここまで、コンパイラ作成のおおまかな流れを解説しましたが、いかがでしたでしょうか？C++を使った実際の実装はここまでとしたいと思います。これから変数などのいわゆる「プログラミング言語」らしい機能を紹介したいと思いますが、これらの実装を詳しく説明するのは流石に骨が折れるので、概要だけお話したいと思います。</p><h2 id=比較演算子>比較演算子</h2><p>ここでは比較演算子を説明して　<code>12 > 2</code> などの真の条件式が与えられたら1を、<code>1 == 2</code>などの偽の条件式が与えられたら0を返せるようにします。構文解析木の実装方法は前章で丁寧に扱ったのでそこの部分はEBNFの変更点だけを説明します。まず、最上の階層で <code>expr</code> を使いたいので既存のEBNFを以下のように書き換えます。</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback>add = mul ( &#34;+&#34; mul | &#34;-&#34; mul )*
mul = primary ( &#34;*&#34; primary | &#34;/&#34; primary )*
primary
</code></pre></td></tr></table></div></div><p>また、 <code>==</code> よりも <code>></code> などの不等号のほうが先に結合します(例: <code>1 == 4 > 1</code> の場合、<code>4 > 1</code> が先に1と評価され、その次に <code>1 == 1</code> が評価されます)。MSVCなどのコンパイラで実際に <code>ソース25</code> のようなコードをコンパイルすると <code>false</code> が帰るのでやはり <code>==</code> より <code>></code> が先に結合されることがわかります(もし<code>2 == 2</code> が先に評価されるのであれば、 <code>true</code> が帰るはずです)。</p><p><code>ソース25</code></p><p><img src=(13).png alt></p><p>このことを考慮すると以下のようなEBNFを新たに追加すればいいとわかります。</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback>expr = equality
equality = relational ( &#34;==&#34; relational | &#34;!=&#34; relational )*
relational = add ( &#34;&lt;&#34; add | &#34;&lt;=&#34; add | &#34;&gt;&#34; add | &#34;&gt;=&#34; add )*
</code></pre></td></tr></table></div></div><p>このようなEBNFを設計することで <code>12</code> などの数字単体からなる式や、 <code>1 + 1 > 0</code> などの不等式や、 <code>2(3 + 4) > 10 == 1</code> などのような不等号と等号を混ぜた式まで構文解析できるようになります。ここまでの段階で比較演算子に対応した <code>Parse()</code> を実装することができます。
次に比較演算子に対応した <code>GenerateAssembly()</code> すなわちアセンブリコードの生成の実装を説明します。 基本は四則演算のアセンブリ生成と同じ流れです。木全体を走査して、 <code>+</code> ノードであれば <code>add</code> 命令を生成するのと同様に <code>></code> や <code>==</code> ノードであればそれに対応したアセンブリの命令を生成すればよいです。以下にその命令を示します。</p><table><thead><tr><th style=text-align:left>命令</th><th style=text-align:left>命令の意味</th></tr></thead><tbody><tr><td style=text-align:left><code>cmp r1, r2</code></td><td style=text-align:left>整数レジスタr1とr2の値を比較して比較結果をフラグレジスタに格納する</td></tr><tr><td style=text-align:left><code>sete al</code></td><td style=text-align:left>フラグレジスタを読み取って、<code>cmp</code>命令の比較結果が <code>r1 == r2</code> となったら <code>al</code> レジスタに<code>1</code>を格納する</td></tr><tr><td style=text-align:left><code>setne al</code></td><td style=text-align:left>フラグレジスタを読み取って、<code>cmp</code>命令の比較結果が <code>r1 != r2</code> となったら <code>al</code> レジスタに<code>1</code>を格納する</td></tr><tr><td style=text-align:left><code>setl al</code></td><td style=text-align:left>フラグレジスタを読み取って、<code>cmp</code>命令の比較結果が <code>r1 &lt; r2</code> となったら <code>al</code> レジスタに<code>1</code>を格納する</td></tr><tr><td style=text-align:left><code>setle al</code></td><td style=text-align:left>フラグレジスタを読み取って、<code>cmp</code>命令の比較結果が <code>r1 &lt;= r2</code> となったら <code>al</code> レジスタに<code>1</code>を格納する</td></tr></tbody></table><p>ただしここで一つ注意があります。上の表で <code>al</code> というレジスタを用いましたが、実はこれは頻繁に使う整数レジスタ <code>rax</code> の下位8bitに割り当てられた別名レジスタに過ぎないのです。従って比較結果を<code>rax</code>に格納したい場合は残りの56bitを0で埋める必要があります。それを行ってくれるのが <code>movzb</code> 命令です。なお、ここでは <code>></code> と <code>>=</code> に対応する命令を紹介していませんが、単に構文解析時に右辺と左辺を入れ替えれば <code>></code> や <code>>=</code> は <code>&lt;</code> や <code>&lt;=</code> に置換可能です。<code>A > B</code> は<code>B &lt; A</code> と同値であるからです。</p><table><thead><tr><th style=text-align:left>命令</th><th style=text-align:left>命令の意味</th></tr></thead><tbody><tr><td style=text-align:left><code>movzb rax al</code></td><td style=text-align:left><code>rax</code> レジスタの <code>al</code> 部分はそのままで残りの56bitをゼロクリアする</td></tr></tbody></table><p>以上を踏まえて実装すると以下のようになります(掲載しているのは <code>GenerateAssembly</code> 関数の<code>switch</code> 文の新規ラベルです)。ちなみに構文解析木では、<code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&lt;=</code> がそれぞれ <code>NODETYPE::EQUAL</code>, <code>NODETYPE::NOT_EQUAL</code>, <code>NODETYPE::LESS</code>, <code>NODETYPE::LESS_OR_EQUAL</code> に対応しています。</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">16
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">17
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">18
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">19
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">20
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">21
</span><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">22
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback>case NODETYPE::EQUAL:
    //ここが処理されている段階で `A == B` のAがraxレジスタに、Bがrdiレジスタに格納されている
    res += &#34;\tcmp rax, rdi\n&#34;;
    res += &#34;\tsete al\n&#34;;
    res += &#34;\tmovzb rax, al\n&#34;;
    break;
case NODETYPE::NOT_EQUAL:
    //以下同様に実装していく
    res += &#34;\tcmp rax, rdi\n&#34;;
    res += &#34;\tsetne al\n&#34;;
    res += &#34;\tmovzb rax, al\n&#34;;
    break;
case NODETYPE::LESS:
    res += &#34;\tcmp rax, rdi\n&#34;;
    res += &#34;\tsetl al\n&#34;;
    res += &#34;\tmovzb rax, al\n&#34;;
    break;
case NODETYPE::LESS_OR_EQUAL:
    res += &#34;\tcmp rax, rdi\n&#34;;
    res += &#34;\tsetle al\n&#34;;
    res += &#34;\tmovzb rax, al\n&#34;;
    break;
</code></pre></td></tr></table></div></div><p>今まで長々と説明してきましたがいざ実装すると意外とあっけなかったですね。ここまで以下のようなコードがコンパイルできるようになります。</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback>1 == 1 &lt;= 0
</code></pre></td></tr></table></div></div><h2 id=おわりに>おわりに</h2><p>さあ、ここまで比較演算子の実装まで終わりました。私はC言語の主要な機能(ローカル変数、関数、ポインタなど)を実装したのですが、私が今これを執筆しているのが2021年9月25日で、時間がキツキツになっているのでここで終わりとしたいと思います。今回の部誌でコンパイラについて興味を持ってくれる人がいたら幸いです。もし、私のコードの全体が見たい人がいたら1章に載せたメールアドレスに連絡してください。読んでいただきありがとうございました！！</p></div><nav class=nextPrev><div class=next>次へ<a href=https://asanobuturi.github.io/document/2021/11/>編集後記＞</a></div><div class=next>前へ<a href=https://asanobuturi.github.io/document/2021/9/>コイルガン 四年間のすべて＞</a></div></nav></div><nav id=sidebar><div id=sidemenu><div class=side-back><a href=../index.html>記事の一覧へもどる<img src=/image/icons/sign-out-alt-solid.svg class=inline-image></a></div><div class=side-prev><a href=https://asanobuturi.github.io/document/2021/9/><img src=/image/icons/angle-left-solid.svg class=inline-image>コイルガン 四年間のすべて</a></div><div class=side-next><a href=https://asanobuturi.github.io/document/2021/11/>編集後記<img src=/image/icons/angle-right-solid.svg class=inline-image></a></div></div><div id=indexblock><div class=indextitle>目次</div><ol class=indexcontents><nav id=TableOfContents><ul><li><a href=#はじめに>はじめに</a></li><li><a href=#対象読者>対象読者</a></li><li><a href=#コンパイラとはなんぞや>コンパイラとはなんぞや</a></li><li><a href=#コンパイルの手順>コンパイルの手順</a></li><li><a href=#開発環境>開発環境</a></li><li><a href=#構文解析>構文解析</a></li><li><a href=#アセンブリで四則演算>アセンブリで四則演算</a></li><li><a href=#アセンブリコードの自動生成>アセンブリコードの自動生成</a></li><li><a href=#比較演算子>比較演算子</a></li><li><a href=#おわりに>おわりに</a></li></ul></nav></ol></div></nav></div><footer class=footer><p class=copyright>Copyright &copy; 2015 - 2022 Asano Physics Club, All Rights Reversed.</p><p class=note></p></footer></main></body></html>